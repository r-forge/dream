##' Metropolis rule for acceptance or rejection
##'
##' @param x matrix nseq x ndim
##' @param p.x vector of length nseq
##' @param logp.x vector of length nseq
##' @param x.old matrix nseq x ndim
##' @param p.old vector of length nseq
##' @param logp.old vector of length nseq
##' @param measurement. needs N and sigma
##' @param control list with elements:
##'   gamma
##'   metrop.opt range [1,5] 
##' @return ... list with elements
##'   newgen matrix nseq x ndim+2 (same as X in dream.R)
##'   alpha scalar probability of acceptance. range [0,1]
##'   accept vector indicating whether each sequences was accepted. length nseq
##  TODO: names for control$metrop.opt.
metrop<-function(x,p.x,logp.x,
                 x.old,p.old,logp.old,
                 measurement,control
                 ){

  ## dimensions:
  ##  nr.chains scalar. should be = control$nseq
  ##  Z vector of length nseq range [0,1]
  ##  idx vector length [0,nseq] range [1,nseq]
  
  ## Calculate the number of Chains
  ## TODO: redundant because always equal to control$nseq?
  nr.chains <- nrow(x)
  
  ## First set newgen to the old positions in X
  newgen <- cbind(x.old,p.old,logp.old)
  
  ## And initialize accept with false
  accept <- rep(FALSE,nr.chains)
  
  switch(control$metrop.opt,
         "1" = {
           alpha <- min(p.x/p.old,1)
         },
         "2" = { ## Lnp probability evaluation
           alpha <- min(exp(p.x-p.old),1)
         },
         "3" = { ## SSE probability evaluation
           alpha <- min((p.x/p.old)^(-measurement$N*(1+control$gamma)/2),1)
         },
         "4" = { ## Lnp probability evaluation
           alpha <- min(exp(p.x-p.old),1)
         },
         "5" = { ## Similar to 3 but now weighted with Measurement.Sigma
           ## signs are different because we write -SSR
           alpha <- min(exp(-0.5*(-p.x + p.old)/measurement$sigma^2),1);
         })

  ## Generate random numbers
  Z <- runif(nr.chains)
  ## Find which alpha's are greater than Z
  idx <- which(Z<alpha)
  ## And update these chains
  newgen[idx,] <- c(x[idx,],p.x[idx],logp.x[idx])
         
  ## And indicate that these chains have been accepted
  accept[idx] <- TRUE

  return(list(newgen=newgen,alpha=alpha,accept=accept))
} ##metrop
